README

1) Isabel Herrero Estrada

2) 4428654619

3) What you have done in the assignment
- xorOperation(): The function iterates through two strings character by character, comparing firstString[i] to secondString[i] at each position i. If they are the same, the condition is true and it evaluates to '0'. If they are different, the condition is false and it evaluates to '1'. This is done to introduce the random bits of error to the codeword.
- appendZeros(): Takes a string of binary data and an integer n and returns a new string with n zeros appended to the end. This is needed because when doing CRC and checksum it is necessary to pad the data to a specific length and so that the division process is correct.
- calculateCRC(): Computes the CRC remainder for the given binary data string and a generator polynomial. It performs a binary polynomial division to find the remainder, which serves as the CRC code. The function first determines the length of the polynomial (polynomialLength). Then calls appendZeros to append zeros to the end of the binaryData string. The result is stored in paddedBinaryData. The crcRemainder is initialized with the first polynomialLength characters of the paddedBinaryData string. The for loop iterates from the end of the initial crcRemainder to the end of the paddedBinaryData string, one bit at a time. The if (remainder[0] == '1') statement checks the most significant bit of the current remainder. If the most significant bit is '1', the remainder is XORed with the generator polynomial (crc16Generator). Basically, subtracting the polynomial in binary. If the most significant bit is '0', the remainder is XORed with a string of all zeros, which doesn't change the remainder. After the XOR operation, the next bit from the paddedBinaryData is appended to the remainder. This shifts the remainder to the left and brings in the next bit of the data for the next iteration of the division. After the loop finishes, the crcRemainder string contains the final CRC code. The crcRemainder.substr(1) call returns the remainder without its leading bit since it is discarded.
- introduceError(): First checks that the errorBit string has the same length as the binaryCodeword by padding it with leading zeros if needed. Then uses appendZeros function to handle the padding. Once the strings are of equal length, it calls xorOperation function to perform a XOR operation. This operation flips the bits of the binaryCodeword at every position where the errorBit string has a '1'. After, the function returns the corrupted codeword.
- splitBlocks(): Takes a binary data string and a block size and divides the string into smaller, fixed-length strings, and stores them in a vector. The function iterates through the input binaryData string, extracting a substring of blockSize for each loop. If the final binaryDataSegment is shorter than blockSize, the function pads it with zeros to ensure all blocks are of uniform length.
- calculateChecksumValue(): Computes a 16-bit one's complement checksum on a string of binary data. It first divides the input binaryData string into 16-bit segments using the splitBlocks function. The code then iterates through each 16-bit segment. It converts each segment from a binary string to an integer using stoi and adds it to blockSum. The while loop handles any carry that exceeds the 16-bit limit and the carry bit is added back to the blockSum. After all blocks are summed and the carry is handled, the function calculates the one's complement of the final sum using the bitwise NOT operator (~). The & 0xFFFF operation ensures the result is masked to 16 bits. This operation flips every bit of the calculated sum. The function returns a final unsigned int value. This value is used to generate a checksum to be transmitted with the data and to verify if received data has been corrupted.
- calculateTotalChecksum(): The function calls calculateChecksumValue to perform the one's complement checksum on the input binaryData. The bitset<16> b_finalChecksum(finalChecksum) line creates a 16-bit bitset object and converts the integer finalChecksum into its binary.
Then, it calls the .to_string() method on the bitset object to convert the sequence of bits into a standard string of '0's and '1's.
- verifyChecksum(): Checks if a received data string is error-free using a checksum and returns a boolean value. Calls calculateChecksumValue(receivedData) to perform the checksum calculation on the entire received string, which includes both the data and the original checksum. Compares the result to zero. Returns true if the result is '0', indicating the data is valid and no errors were detected. Returns false if the result is anything other than '0', signaling that an error occurred during transmission.
- errorDetection(): The function prints the original binaryData and the errorBit string. It calculates a CRC remainder for the binaryData using calculateCRC and appends it to create a crcCodeword. The introduceError function then simulates a transmission error by applying the errorBit to the crcCodeword, creating corruptedCRC. It recalculates the CRC remainder of the corruptedCRC. If the remainder is zero, the CRC test passes, meaning the error was successfully detected. It prints "Pass" or "Not pass" accordingly. It calculates a checksum value for the binaryData using calculateTotalChecksum and appends it to create a checksumCodeword. It applies the error to this codeword to create corruptedChecksum. The verifyChecksum function is called on the corrupted data. This function recalculates the checksum and checks if it validates. It prints "Pass" if the checksum is verified and "Not pass" otherwise.

4) What your code files are and what each one does (please do not repeat the project description, just name your code files and briefly mention their purpose)
Makefile: 
- make all: compiles and run error_detection.cpp, print the results and store them in error_detection file
- make clean: removes error_detection file eliminating previous printed results
error_detection.cpp:
- main()
- xorOperation()
- appendZeros()
- calculateCRC()
- introduceError()
- splitBlocks()
- calculateChecksumValue()
- calculateTotalChecksum()
- verifyChecksum()
- errorDetection()

5) Any idiosyncrasies of your project, including under what conditions the project might fail, if any
Possible failures in this project:
    1. Did not include an error checking method that makes sure that the data.txt is able to be open and read. Without checking this, could run into a runtime error where the program is trying to read a file it cannot open and therefore not automatically exiting the program.
    2. Could have added a way to check that both columns of information in the data.txt where populated with something. I did not include in the program the ability to check if the data column is empty nor check if the error column is empty.


6) Reused code: Did you use code from anywhere for your project? If not, state that. If so, specify
what functions were reused and where theyâ€™re from (also include comments in the source code to
identify reused sections)
- size_t instead of using int: https://www.geeksforgeeks.org/cpp/difference-between-int-and-size_t-in-cpp/
-> Preferred using size_t because is guaranteed to be large enough and does not include negative numbers, which allows error prevention.
- CRC References:
-> https://www.geeksforgeeks.org/dsa/modulo-2-binary-division/
-> https://cplusplus.com/forum/beginner/224344/
-> https://www.youtube.com/watch?v=5oNx3G8uBW8
- bitset Reference:
-> https://www.geeksforgeeks.org/cpp/cpp-bitset-and-its-application/
- const, &, nullptr Reference:
-> Learned it at my previous employment HP Inc. 
- substr Reference:
-> https://cplusplus.com/reference/string/string/substr/
- push_back Reference:
-> https://www.geeksforgeeks.org/cpp/vector-push-back-cpp-stl/
- Checksum References:
-> https://www.geeksforgeeks.org/computer-networks/c-c-program-to-implement-checksum/
-> https://cboard.cprogramming.com/cplusplus-programming/133784-calculating-checksum.html
-> https://www.youtube.com/watch?v=AtVWnyDDaDI
- stoi Reference:
-> https://cplusplus.com/reference/string/stoi/
- ~ Reference:
-> https://www.geeksforgeeks.org/cpp/cpp-bitwise-operators/#4bitwise-not-
- Overall References:
-> Book "Effective Modern C++" by Scott Meyers

